<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<head>
    <meta charset="UTF-8">
    <title>도서 상세</title>
    <style>
        body { font-family: system-ui, sans-serif; max-width: 800px; margin: 40px auto; }
        .layout { display: flex; gap: 16px; }
        .cover { width: 400px; }
        .cover img { width: 100%; object-fit: cover; }
        .info h1 { margin: 0 0 8px; font-size: 1.5rem; }
        .meta { color: #555; margin-bottom: 8px; }
        .pages { color: #555; margin-bottom: 8px; }
        .desc { margin-bottom: 16px; white-space: pre-line; }
        section { margin-top: 24px; }
        section h2 { font-size: 1.1rem; margin-bottom: 8px; }
        input[type="number"], textarea {
            width: 100%; padding: 6px; box-sizing: border-box;
        }
        button { padding: 6px 10px; margin-top: 4px; cursor: pointer; }
        a { display:block; margin-bottom: 20px; }

        /* ===== 페이지 코멘트 모달 ===== */
        .modal.hidden { display: none; }
        .modal {
            position: fixed;
            inset: 0;
            z-index: 9999;
        }
        .modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.45);
        }
        .modal-content {
            position: relative;
            max-width: 650px;
            margin: 60px auto;
            background: #fff;
            border-radius: 8px;
            padding: 16px 20px 20px;
            box-shadow: 0 12px 30px rgba(0,0,0,0.2);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 1.2rem;
        }
        .close-btn {
            border: none;
            background: transparent;
            font-size: 18px;
            cursor: pointer;
        }
        .modal-body {
            font-size: 0.95rem;
        }
        .comment-list {
            list-style: none;
            padding: 0;
            margin: 8px 0 0;
            border: 1px solid #eee;
            border-radius: 4px;
            max-height: 260px;
            overflow-y: auto;
        }
        .comment-list-empty {
            padding: 8px;
            color: #666;
            font-size: 0.9rem;
        }
        .comment-item {
            border-bottom: 1px solid #eee;
            padding: 6px 8px;
            font-size: 0.9rem;
        }
        .comment-item:last-child { border-bottom: none; }
        .comment-meta {
            font-size: 0.8rem;
            color: #777;
            margin-bottom: 2px;
        }

        /* ===== 리뷰 리스트 ===== */
        .review-item {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .review-meta {
            font-size: 0.8rem;
            color: #777;
            margin-bottom: 4px;
        }
        .review-body {
            white-space: pre-line;
        }
    </style>
</head>
<body>
<a href="/">← 검색으로 돌아가기</a>

<div class="layout">
    <div class="cover">
        <img id="cover" src="" alt="cover">
    </div>
    <div class="info">
        <h1 id="title">제목</h1>
        <div class="meta" id="meta"></div>
        <div class="pages" id="pages"></div>
        <div class="desc" id="desc"></div>
    </div>
</div>

<section>
    <h2>진행도</h2>
    <div>
        현재 페이지: <span id="currentPage">0</span>
    </div>
    <div style="margin-top:6px;">
        <input id="progressInput" type="number" min="0" placeholder="현재 읽은 페이지">
        <button id="progressBtn">저장</button>
    </div>
</section>

<!-- ✅ 페이지 코멘트: 빠른 입력 + 모달 -->
<section>
    <h2>페이지 코멘트</h2>

    <!-- 모달 열기 버튼 -->
    <button id="openCommentModalBtn">페이지 코멘트 창 열기</button>

    <!-- 바로 아래에서 빠르게 코멘트 저장 -->
    <div style="margin-top:10px;">
        <input id="quickCommentPage" type="number" min="1"
               placeholder="코멘트를 남길 페이지 번호">
    </div>
    <div style="margin-top:4px;">
        <textarea id="quickCommentText" rows="3"
                  placeholder="이 페이지에 대한 코멘트를 바로 작성해 저장할 수 있습니다."></textarea>
        <button id="quickCommentBtn" type="button">코멘트 추가</button>
    </div>
</section>

<section>
    <h2>총평 (리뷰)</h2>

    <!-- 여러 개의 리뷰를 전부 보여주는 영역 -->
    <div id="reviewList"></div>

    <!-- 리뷰 작성 -->
    <div style="margin-top:10px;">
        <textarea id="reviewText" rows="3" placeholder="총평을 작성하세요"></textarea><br>
        <label>
            <input type="checkbox" id="reviewSpoiler">
            스포일러 포함
        </label><br>
        <button id="reviewBtn">리뷰 저장</button>
    </div>
</section>

<!-- 모달(페이지 내부에서 뜨는 창) -->
<div id="commentModal" class="modal hidden">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>페이지 코멘트</h2>
            <button type="button" class="close-btn" id="closeCommentModalBtn">✕</button>
        </div>
        <div class="modal-body">

            <!-- 작성 대상 페이지 표시 -->
            <div style="margin-bottom:10px;">
                <label>
                    페이지:
                    <input id="modalCommentPage" type="number" min="1" style="width:80px;">
                </label>
            </div>
            <div style="margin-bottom:10px;">
                <textarea id="modalCommentText" rows="3" placeholder="이 페이지에 대한 코멘트를 작성하세요"></textarea>
                <button id="modalAddCommentBtn" type="button">코멘트 추가</button>
            </div>

            <!-- 필터 + 정렬 -->
            <div style="margin-bottom:10px; padding:8px; border:1px solid #eee; border-radius:4px; font-size:0.9rem;">
                <div style="margin-bottom:6px; font-weight:600;">표시 옵션</div>
                <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
                    <span>페이지 범위:</span>
                    <input id="filterFrom" type="number" min="1" placeholder="from" style="width:80px;">
                    <span>~</span>
                    <input id="filterTo" type="number" min="1" placeholder="to" style="width:80px;">

                    <span style="margin-left:12px;">정렬:</span>
                    <select id="sortOrder">
                        <option value="asc">페이지 오름차순</option>
                        <option value="desc">페이지 내림차순</option>
                    </select>

                    <button id="applyFilterBtn" type="button">적용</button>
                    <button id="resetFilterBtn" type="button">초기화</button>
                </div>
            </div>

            <div id="modalPageInfo" style="font-size:0.9rem; color:#555; margin-bottom:6px;"></div>

            <!-- 코멘트 리스트 -->
            <ul id="modalCommentList" class="comment-list"></ul>
        </div>
    </div>
</div>

<script th:inline="javascript">
    const isbn13 = /*[[${isbn13}]]*/ "";
    let allComments = [];   // 전체 코멘트 캐시
    let currentWritePage = 1;

    async function loadDetail() {
        try {
            const res = await fetch(`/api/books/${isbn13}`);
            if (!res.ok) return;
            const b = await res.json();
            document.getElementById('title').textContent = b.title;
            document.getElementById('meta').textContent =
                (b.authors && b.authors.length ? b.authors.join(', ') : '') +
                ' | ' + (b.publisher || '');
            document.getElementById('pages').textContent = b.pageCount ? `${b.pageCount}쪽` : '';
            document.getElementById('desc').textContent = b.description || '';
            const cover = document.getElementById('cover');
            cover.src = b.coverUrl || '';
            cover.alt = b.title;
        } catch (e) {
            console.error(e);
        }
    }

    async function loadProgress() {
        try {
            const res = await fetch(`/api/books/${isbn13}/progress`);
            if (!res.ok) return;
            const data = await res.json();
            document.getElementById('currentPage').textContent = data.currentPage ?? 0;
        } catch (e) {
            console.error(e);
        }
    }

    async function saveProgress() {
        const v = document.getElementById('progressInput').value;
        const n = Number(v);
        if (Number.isNaN(n) || n < 0) return alert('0 이상 숫자를 입력하세요.');
        try {
            const res = await fetch(`/api/books/${isbn13}/progress`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ currentPage: n })
            });
            if (!res.ok) {
                alert('저장 실패: ' + res.status);
                return;
            }
            await loadProgress();
        } catch (e) {
            console.error(e);
            alert('오류 발생');
        }
    }

    // ===== 여러 개의 리뷰 로딩 =====
    async function loadReviews() {
        const container = document.getElementById('reviewList');
        container.innerHTML = '';

        try {
            const res = await fetch(`/api/books/${isbn13}/reviews`);
            if (!res.ok) {
                container.textContent = '리뷰를 불러오지 못했습니다.';
                return;
            }
            const data = await res.json();

            const reviews = Array.isArray(data)
                ? data
                : (data ? [data] : []);  // 혹시 단일 객체를 리턴하더라도 대응

            if (reviews.length === 0) {
                container.textContent = '아직 등록된 리뷰가 없습니다.';
                return;
            }

            // 최신 작성일 순으로 정렬 (createdAt 없으면 그대로)
            reviews.sort((a, b) => {
                const ta = a.createdAt ? new Date(a.createdAt).getTime() : 0;
                const tb = b.createdAt ? new Date(b.createdAt).getTime() : 0;
                return tb - ta;
            });

            reviews.forEach((r, idx) => {
                const item = document.createElement('div');
                item.className = 'review-item';

                const meta = document.createElement('div');
                meta.className = 'review-meta';
                const dateStr = r.createdAt
                    ? new Date(r.createdAt).toLocaleString('ko-KR')
                    : '';
                meta.textContent =
                    `${idx === 0 ? '최근 리뷰' : `리뷰 #${reviews.length - idx}`} ` +
                    (dateStr ? `• ${dateStr}` : '') +
                    (r.spoiler ? ' • 스포일러 포함' : '');

                const body = document.createElement('div');
                body.className = 'review-body';

                if (r.spoiler) {
                    // 기본은 내용 숨기고 안내 문구 + 버튼
                    const placeholder = document.createElement('div');
                    placeholder.textContent = '스포일러가 포함된 리뷰입니다. "보기" 버튼을 눌러 내용을 확인하세요.';

                    const real = document.createElement('div');
                    real.textContent = r.overall;
                    real.style.display = 'none';

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.textContent = '스포일러 보기';
                    btn.addEventListener('click', () => {
                        const isHidden = real.style.display === 'none';
                        real.style.display = isHidden ? 'block' : 'none';
                        btn.textContent = isHidden ? '스포일러 숨기기' : '스포일러 보기';
                    });

                    body.appendChild(placeholder);
                    body.appendChild(real);
                    body.appendChild(btn);
                } else {
                    body.textContent = r.overall;
                }

                item.appendChild(meta);
                item.appendChild(body);
                container.appendChild(item);
            });
        } catch (e) {
            console.error(e);
            container.textContent = '리뷰를 불러오는 중 오류가 발생했습니다.';
        }
    }

    async function saveReview() {
        const text    = document.getElementById('reviewText').value.trim();
        const spoiler = document.getElementById('reviewSpoiler').checked;
        if (!text) return alert('리뷰 내용을 입력하세요.');
        try {
            const res = await fetch(`/api/books/${isbn13}/review`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ overall: text, spoiler: spoiler })
            });
            if (!res.ok) {
                alert('리뷰 저장 실패: ' + res.status);
                return;
            }
            document.getElementById('reviewText').value = '';
            document.getElementById('reviewSpoiler').checked = false;
            await loadReviews();   // 저장 후 전체 목록 다시 로딩
        } catch (e) {
            console.error(e);
            alert('오류 발생');
        }
    }

    // ===== 모달용 공통 =====
    function updateModalPageInfo() {
        const info = document.getElementById('modalPageInfo');
        info.textContent = `현재 작성 대상 페이지: p.${currentWritePage}`;
    }

    function renderModalComments() {
        const listEl = document.getElementById('modalCommentList');
        const fromEl = document.getElementById('filterFrom');
        const toEl   = document.getElementById('filterTo');
        const sortEl = document.getElementById('sortOrder');

        listEl.innerHTML = '';

        if (!allComments || allComments.length === 0) {
            const empty = document.createElement('li');
            empty.className = 'comment-list-empty';
            empty.textContent = '등록된 코멘트가 없습니다.';
            listEl.appendChild(empty);
            return;
        }

        let list = allComments.slice();

        const fromVal = Number(fromEl.value);
        const toVal   = Number(toEl.value);
        const hasFrom = !Number.isNaN(fromVal) && fromVal >= 1;
        const hasTo   = !Number.isNaN(toVal)   && toVal   >= 1;

        if (hasFrom) list = list.filter(c => c.page >= fromVal);
        if (hasTo)   list = list.filter(c => c.page <= toVal);

        if (sortEl.value === 'asc') {
            list.sort((a, b) => a.page - b.page);
        } else {
            list.sort((a, b) => b.page - a.page);
        }

        if (list.length === 0) {
            const empty = document.createElement('li');
            empty.className = 'comment-list-empty';
            empty.textContent = '해당 조건에 맞는 코멘트가 없습니다.';
            listEl.appendChild(empty);
            return;
        }

        list.forEach(c => {
            const li = document.createElement('li');
            li.className = 'comment-item';

            const meta = document.createElement('div');
            meta.className = 'comment-meta';
            meta.textContent = `p.${c.page}`;

            const body = document.createElement('div');
            body.textContent = c.comment;

            li.appendChild(meta);
            li.appendChild(body);
            listEl.appendChild(li);
        });
    }

    async function fetchAllComments() {
        try {
            const res = await fetch(`/api/books/${isbn13}/page-comments`);
            if (!res.ok) {
                allComments = [];
                return;
            }
            const data = await res.json();
            allComments = Array.isArray(data) ? data : [];
        } catch (e) {
            console.error(e);
            allComments = [];
        }
    }

    async function reloadModalComments() {
        await fetchAllComments();
        renderModalComments();
    }

    function openCommentModal() {
        // 기본 페이지: 빠른 입력란 > 진행도 > 1
        const quickPage = Number(document.getElementById('quickCommentPage').value);
        const currentPage = Number(document.getElementById('currentPage').textContent);

        if (!Number.isNaN(quickPage) && quickPage >= 1) {
            currentWritePage = quickPage;
        } else if (!Number.isNaN(currentPage) && currentPage >= 1) {
            currentWritePage = currentPage;
        } else {
            currentWritePage = 1;
        }

        document.getElementById('modalCommentPage').value = currentWritePage;
        updateModalPageInfo();

        document.getElementById('commentModal').classList.remove('hidden');
        reloadModalComments();
    }

    function closeCommentModal() {
        document.getElementById('commentModal').classList.add('hidden');
    }

    async function addCommentFromModal() {
        const pageInput = document.getElementById('modalCommentPage');
        const textEl    = document.getElementById('modalCommentText');

        const page = Number(pageInput.value);
        const text = textEl.value.trim();

        if (Number.isNaN(page) || page < 1 || !text) {
            alert('페이지(>=1)와 코멘트를 입력하세요.');
            return;
        }

        try {
            const res = await fetch(`/api/books/${isbn13}/page-comments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ page: page, comment: text })
            });
            if (!res.ok) {
                alert('코멘트 저장 실패: ' + res.status);
                return;
            }
            textEl.value = '';
            currentWritePage = page;
            document.getElementById('modalCommentPage').value = currentWritePage;
            updateModalPageInfo();
            await reloadModalComments();
        } catch (e) {
            console.error(e);
            alert('오류 발생');
        }
    }

    // ===== 빠른 입력용 =====
    async function addQuickComment() {
        const pageInput = document.getElementById('quickCommentPage');
        const textEl    = document.getElementById('quickCommentText');

        const page = Number(pageInput.value);
        const text = textEl.value.trim();

        if (Number.isNaN(page) || page < 1 || !text) {
            alert('페이지(>=1)와 코멘트를 입력하세요.');
            return;
        }

        try {
            const res = await fetch(`/api/books/${isbn13}/page-comments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ page: page, comment: text })
            });
            if (!res.ok) {
                alert('코멘트 저장 실패: ' + res.status);
                return;
            }
            textEl.value = '';
            // 모달이 열려 있다면 리스트 갱신
            if (!document.getElementById('commentModal').classList.contains('hidden')) {
                await reloadModalComments();
            }
        } catch (e) {
            console.error(e);
            alert('오류 발생');
        }
    }

    // ===== 이벤트 바인딩 =====
    document.getElementById('progressBtn').addEventListener('click', saveProgress);
    document.getElementById('reviewBtn').addEventListener('click', saveReview);

    document.getElementById('openCommentModalBtn').addEventListener('click', openCommentModal);
    document.getElementById('closeCommentModalBtn').addEventListener('click', closeCommentModal);
    document.querySelector('#commentModal .modal-backdrop')
        .addEventListener('click', closeCommentModal);

    document.getElementById('modalAddCommentBtn').addEventListener('click', addCommentFromModal);

    document.getElementById('applyFilterBtn').addEventListener('click', renderModalComments);
    document.getElementById('resetFilterBtn').addEventListener('click', () => {
        document.getElementById('filterFrom').value = '';
        document.getElementById('filterTo').value   = '';
        document.getElementById('sortOrder').value  = 'asc';
        renderModalComments();
    });

    document.getElementById('modalCommentPage').addEventListener('input', (e) => {
        const v = Number(e.target.value);
        if (!Number.isNaN(v) && v >= 1) {
            currentWritePage = v;
            updateModalPageInfo();
        }
    });

    document.getElementById('quickCommentBtn').addEventListener('click', addQuickComment);

    // 초기 로딩
    loadDetail();
    loadProgress();
    loadReviews();
</script>
</body>
</html>
